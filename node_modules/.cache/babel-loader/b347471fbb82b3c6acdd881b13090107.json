{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React, { Component } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport detectElementOverflow from 'detect-element-overflow';\nimport warning from 'tiny-warning';\nvar isBrowser = typeof document !== 'undefined';\nvar isDisplayContentsSupported = isBrowser && 'CSS' in window && 'supports' in window.CSS && CSS.supports('display', 'contents');\nvar isMutationObserverSupported = isBrowser && 'MutationObserver' in window;\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction findScrollContainer(element) {\n  var parent = element.parentElement;\n  while (parent) {\n    var overflow = window.getComputedStyle(parent).overflow;\n    if (overflow.split(' ').every(function (o) {\n      return o === 'auto' || o === 'scroll';\n    })) {\n      return parent;\n    }\n    parent = parent.parentElement;\n  }\n  return document.documentElement;\n}\nfunction alignAxis(_a) {\n  var axis = _a.axis,\n    container = _a.container,\n    element = _a.element,\n    invertAxis = _a.invertAxis,\n    secondary = _a.secondary,\n    scrollContainer = _a.scrollContainer,\n    spacing = _a.spacing;\n  var style = window.getComputedStyle(element);\n  var parent = container.parentElement;\n  if (!parent) {\n    return;\n  }\n  var scrollContainerCollisions = detectElementOverflow(parent, scrollContainer);\n  var documentCollisions = detectElementOverflow(parent, document.documentElement);\n  var isX = axis === 'x';\n  var startProperty = isX ? 'left' : 'top';\n  var endProperty = isX ? 'right' : 'bottom';\n  var sizeProperty = isX ? 'width' : 'height';\n  var overflowStartProperty = \"overflow\".concat(capitalize(startProperty));\n  var overflowEndProperty = \"overflow\".concat(capitalize(endProperty));\n  var scrollProperty = \"scroll\".concat(capitalize(startProperty));\n  var uppercasedSizeProperty = capitalize(sizeProperty);\n  var offsetSizeProperty = \"offset\".concat(uppercasedSizeProperty);\n  var clientSizeProperty = \"client\".concat(uppercasedSizeProperty);\n  var minSizeProperty = \"min-\".concat(sizeProperty);\n  var scrollbarWidth = scrollContainer[offsetSizeProperty] - scrollContainer[clientSizeProperty];\n  var startSpacing = typeof spacing === 'object' ? spacing[startProperty] : spacing;\n  var availableStartSpace = -Math.max(scrollContainerCollisions[overflowStartProperty], documentCollisions[overflowStartProperty] + document.documentElement[scrollProperty]) - startSpacing;\n  var endSpacing = typeof spacing === 'object' ? spacing[endProperty] : spacing;\n  var availableEndSpace = -Math.max(scrollContainerCollisions[overflowEndProperty], documentCollisions[overflowEndProperty] - document.documentElement[scrollProperty]) - endSpacing - scrollbarWidth;\n  if (secondary) {\n    availableStartSpace += parent[clientSizeProperty];\n    availableEndSpace += parent[clientSizeProperty];\n  }\n  var offsetSize = element[offsetSizeProperty];\n  function displayStart() {\n    element.style[startProperty] = 'auto';\n    element.style[endProperty] = secondary ? '0' : '100%';\n  }\n  function displayEnd() {\n    element.style[startProperty] = secondary ? '0' : '100%';\n    element.style[endProperty] = 'auto';\n  }\n  function displayIfFits(availableSpace, display) {\n    var fits = offsetSize <= availableSpace;\n    if (fits) {\n      display();\n    }\n    return fits;\n  }\n  function displayStartIfFits() {\n    return displayIfFits(availableStartSpace, displayStart);\n  }\n  function displayEndIfFits() {\n    return displayIfFits(availableEndSpace, displayEnd);\n  }\n  function displayWhereverShrinkedFits() {\n    var moreSpaceStart = availableStartSpace > availableEndSpace;\n    var rawMinSize = style.getPropertyValue(minSizeProperty);\n    var minSize = rawMinSize ? parseInt(rawMinSize, 10) : null;\n    function shrinkToSize(size) {\n      warning(!minSize || size >= minSize, \"<Fit />'s child will not fit anywhere with its current \".concat(minSizeProperty, \" of \").concat(minSize, \"px.\"));\n      var newSize = Math.max(size, minSize || 0);\n      warning(false, \"<Fit />'s child needed to have its \".concat(sizeProperty, \" decreased to \").concat(newSize, \"px.\"));\n      element.style[sizeProperty] = \"\".concat(newSize, \"px\");\n    }\n    if (moreSpaceStart) {\n      shrinkToSize(availableStartSpace);\n      displayStart();\n    } else {\n      shrinkToSize(availableEndSpace);\n      displayEnd();\n    }\n  }\n  var fits;\n  if (invertAxis) {\n    fits = displayStartIfFits() || displayEndIfFits();\n  } else {\n    fits = displayEndIfFits() || displayStartIfFits();\n  }\n  if (!fits) {\n    displayWhereverShrinkedFits();\n  }\n}\nfunction alignMainAxis(args) {\n  alignAxis(args);\n}\nfunction alignSecondaryAxis(args) {\n  alignAxis(__assign(__assign({}, args), {\n    axis: args.axis === 'x' ? 'y' : 'x',\n    secondary: true\n  }));\n}\nfunction alignBothAxis(args) {\n  var invertAxis = args.invertAxis,\n    invertSecondaryAxis = args.invertSecondaryAxis,\n    commonArgs = __rest(args, [\"invertAxis\", \"invertSecondaryAxis\"]);\n  alignMainAxis(__assign(__assign({}, commonArgs), {\n    invertAxis: invertAxis\n  }));\n  alignSecondaryAxis(__assign(__assign({}, commonArgs), {\n    invertAxis: invertSecondaryAxis\n  }));\n}\nvar Fit = /** @class */function (_super) {\n  __extends(Fit, _super);\n  function Fit() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.fit = function () {\n      var _a = _this,\n        scrollContainer = _a.scrollContainer,\n        container = _a.container,\n        element = _a.element;\n      if (!scrollContainer || !container || !element) {\n        return;\n      }\n      var elementWidth = element.clientWidth;\n      var elementHeight = element.clientHeight;\n      // No need to recalculate - already did that for current dimensions\n      if (_this.elementWidth === elementWidth && _this.elementHeight === elementHeight) {\n        return;\n      }\n      // Save the dimensions so that we know we don't need to repeat the function if unchanged\n      _this.elementWidth = elementWidth;\n      _this.elementHeight = elementHeight;\n      var parent = container.parentElement;\n      // Container was unmounted\n      if (!parent) {\n        return;\n      }\n      /**\n       * We need to ensure that <Fit />'s child has a absolute position. Otherwise,\n       * we wouldn't be able to place the child in the correct position.\n       */\n      var style = window.getComputedStyle(element);\n      var position = style.position;\n      if (position !== 'absolute') {\n        element.style.position = 'absolute';\n      }\n      /**\n       * We need to ensure that <Fit />'s parent has a relative or absolute position. Otherwise,\n       * we wouldn't be able to place the child in the correct position.\n       */\n      var parentStyle = window.getComputedStyle(parent);\n      var parentPosition = parentStyle.position;\n      if (parentPosition !== 'relative' && parentPosition !== 'absolute') {\n        parent.style.position = 'relative';\n      }\n      var _b = _this.props,\n        invertAxis = _b.invertAxis,\n        invertSecondaryAxis = _b.invertSecondaryAxis,\n        _c = _b.mainAxis,\n        mainAxis = _c === void 0 ? 'y' : _c,\n        _d = _b.spacing,\n        spacing = _d === void 0 ? 8 : _d;\n      alignBothAxis({\n        container: container,\n        element: element,\n        invertAxis: invertAxis,\n        invertSecondaryAxis: invertSecondaryAxis,\n        axis: mainAxis,\n        scrollContainer: scrollContainer,\n        spacing: spacing\n      });\n    };\n    return _this;\n  }\n  Fit.prototype.componentDidMount = function () {\n    var _this = this;\n    if (!isDisplayContentsSupported) {\n      // eslint-disable-next-line react/no-find-dom-node\n      var element = findDOMNode(this);\n      if (!element || !(element instanceof HTMLElement)) {\n        return;\n      }\n      this.container = element;\n      this.element = element;\n      this.scrollContainer = findScrollContainer(element);\n    }\n    this.fit();\n    var onMutation = function onMutation() {\n      _this.fit();\n    };\n    if (isMutationObserverSupported && this.element) {\n      var mutationObserver = new MutationObserver(onMutation);\n      mutationObserver.observe(this.element, {\n        attributes: true,\n        attributeFilter: ['class', 'style']\n      });\n    }\n  };\n  Fit.prototype.render = function () {\n    var _this = this;\n    var children = this.props.children;\n    var child = React.Children.only(children);\n    if (isDisplayContentsSupported) {\n      return React.createElement(\"span\", {\n        ref: function ref(container) {\n          _this.container = container;\n          var element = container && container.firstElementChild;\n          if (!element || !(element instanceof HTMLElement)) {\n            return;\n          }\n          _this.element = element;\n          _this.scrollContainer = findScrollContainer(element);\n        },\n        style: {\n          display: 'contents'\n        }\n      }, child);\n    }\n    return child;\n  };\n  Fit.propTypes = {\n    children: PropTypes.node.isRequired,\n    invertAxis: PropTypes.bool,\n    invertSecondaryAxis: PropTypes.bool,\n    mainAxis: PropTypes.oneOf(['x', 'y']),\n    spacing: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      bottom: PropTypes.number.isRequired,\n      left: PropTypes.number.isRequired,\n      right: PropTypes.number.isRequired,\n      top: PropTypes.number.isRequired\n    })])\n  };\n  return Fit;\n}(Component);\nexport default Fit;","map":null,"metadata":{},"sourceType":"module"}